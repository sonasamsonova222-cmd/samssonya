СОРТИРОВКА ПУЗЫРЬКОМ:
def bubble_sort(arr):
    # Получаем длину исходного массива
    n = len(arr)
    
    # Внешний цикл проходит по массиву столько раз, сколько элементов в списке минус 1
    for i in range(n):        
        # Внутренний цикл проходит по массиву от начала до конца,
        # уменьшаясь на единицу каждый проход, поскольку наибольший элемент
        # после каждого полного прохода внешнего цикла уже оказывается на своём месте
        for j in range(0, n-i-1):
            # Если текущий элемент больше следующего элемента, меняем их местами
            if arr[j] > arr[j+1]:
                # Меняем элементы местами
                arr[j], arr[j+1] = arr[j+1], arr[j]
                
# Пример использования функции
arr = [64, 34, 25, 12, 22, 11, 90]
print("Исходный массив:", arr)

# Вызываем нашу функцию сортировки
bubble_sort(arr)

# Проверяем отсортированный массив
print("Отсортированный массив:", arr)

ПРИМЕР работы кода:
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]


СОРТИРОВКА ВСТАВКАМИ:
def insertion_sort(arr):
    # Получаем длину массива
    n = len(arr)
    
    # Начинаем перебор со второго элемента (индекс 1),
    # так как первый элемент считается уже отсортированным
    for i in range(1, n):
        key = arr[i]           # Запоминаем текущий элемент
        j = i - 1              # Индекс предыдущего элемента
        
        # Движемся назад по отсортированной части массива
        while j >= 0 and arr[j] > key:
            # Сдвигаем больший элемент вправо
            arr[j + 1] = arr[j]
            j -= 1             # Переходим к следующему предыдущему элементу
            
        # Теперь вставляем ключ на свою правильную позицию
        arr[j + 1] = key       

# Пример использования функции
arr = [64, 34, 25, 12, 22, 11, 90]
print("Исходный массив:", arr)

# Вызываем нашу функцию сортировки
insertion_sort(arr)

# Проверяем отсортированный массив
print("Отсортированный массив:", arr)

ПРИМЕР работы кода:
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]

СОРТИРОВКА ШЕЛЛА
def shell_sort(arr):
    """
    Реализация алгоритма сортировки Шелла.
    """
    n = len(arr)                          # Определяем длину массива
    gap = n // 2                          # Устанавливаем начальный интервал (шаг)
    
    # Начнём с большого шага и будем уменьшать его вдвое на каждой итерации
    while gap > 0:
        # Осуществляем сортировку вставками с заданным шагом
        for i in range(gap, n):
            temp = arr[i]               # Сохраняем текущий элемент
            j = i                       # Индекс для передвижения элементов
            
            # Сравниваем текущий элемент с элементами, расположенными на расстоянии 'gap'
            while j >= gap and arr[j-gap] > temp:
                arr[j] = arr[j-gap]     # Сдвиг большего элемента вперед
                j -= gap                 # Уменьшаем индекс для следующей итерации
            
            arr[j] = temp               # Ставим элемент на его правильную позицию
        
        gap //= 2                       # Уменьшаем шаг вдвое для следующей итерации

# Пример использования
arr = [64, 34, 25, 12, 22, 11, 90]
print("Исходный массив:", arr)
shell_sort(arr)
print("Отсортированный массив:", arr)

ПРИМЕР РАБОТЫ КОДА
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]

БЫСТРАЯ СОРТИРОВКА
def quick_sort(arr):
    """
    Реализация алгоритма быстрой сортировки Quicksort.
    """
    if len(arr) <= 1:
        return arr                               # Базовый случай: пустой или одинарный массив уже отсортированы
    
    pivot = arr[len(arr) // 2]                   # Выбор среднего элемента в качестве опорного (pivot)
    left = [x for x in arr if x < pivot]         # Все элементы меньше pivot'a
    middle = [x for x in arr if x == pivot]      # Все элементы равные pivot'y
    right = [x for x in arr if x > pivot]        # Все элементы больше pivot'a
    
    return quick_sort(left) + middle + quick_sort(right)  # Рекурсивно применяем быструю сортировку к обеим сторонам
                                                         # и соединяем полученные списки


# Пример использования
arr = [64, 34, 25, 12, 22, 11, 90]
print("Исходный массив:", arr)
sorted_arr = quick_sort(arr)
print("Отсортированный массив:", sorted_arr)

ПРИМЕР ВЫВОДА:
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]


ПОСЛЕДОВАТЕЛЬНЫЙ ПОИСК
def sequential_search(arr, target):
    """
    Реализация алгоритма последовательного поиска.
    :param arr: Список, в котором осуществляется поиск.
    :param target: Значение, которое ищем.
    :return: Индекс найденного элемента или None, если элемент не найден.
    """
    # Проходим по каждому элементу массива
    for index, value in enumerate(arr):
        # Если нашли искомое значение
        if value == target:
            return index  # Возвращаем индекс найденного элемента
    return None  # Если элемент не найден, возвращаем None

# Пример использования
array = [10, 20, 30, 40, 50, 60, 70, 80, 90]
target_value = 50

result = sequential_search(array, target_value)

if result is not None:
    print(f"Элемент {target_value} найден на позиции {result}.")
else:
    print(f"Элемент {target_value} не найден.")

ПРИМЕР ВЫВОДА:
Элемент 50 найден на позиции 4.

