      Блочная (корзинная) сортировка
Блочная сортировка (bucket sort) — это алгоритм, который распределяет
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.
    Принцип работы:
1. Определяется количество корзин (например, по диапазону значений элементов).num_buckets = len(arr)
2. Каждый элемент помещается в корзину согласно функции распределения.for value in arr:
        index = int((value - min_val) // step)
3. Содержимое каждой корзины сортируется индивидуально.sorted_arr = []
    for bucket in buckets:
        sorted_bucket = sorted(bucket)
        sorted_arr.extend(sorted_bucket)
4. Корзины соединяются в порядке увеличения диапазона.
    Особенности:
Эффективна для равномерно распределённых числовых данных и может достигать линейной
асимптотики O(n), если размер корзин выбран удачно. Однако эффективность сильно падает
при неравномерном распределении данных.
    Временная сложность (Big-O):O(n).
   Кратко о временной сложности алгоритма Блочной (корзинной) сортировки в нотации Big-O:
Основная идея заключается в том, что основная задача — разделение элементов по корзинам и последующая их сортировка.
Чем лучше распределены элементы изначально, тем ближе реальная производительность к линейной зависимости (O(n)).

     Блинная сортировка
Блинная сортировка (pancake sort) — это метод, основанный на операции
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые
обменивают соседние элементы или выбирают опорные точки, здесь единственная
разрешённая операция — переворот префикса массива до выбранного индекса.
   Принцип работы:
1. Найти максимальный элемент в неотсортированной части массива. def find_max(arr, n):
2. Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот
элемент оказался первым. if mi != curr_size - 1:
            flip(arr, mi)
3. Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце.
4. Повторить процесс для оставшейся неотсортированной части массива.
   Особенности:
Временная сложность (Big-O):O(n2).
  Оценим временную сложность в нотации Big-O:
Каждая итерация включает две операции переворота и поиск максимума. Время переворота пропорционально размеру массива, то есть O(n)O(n).
Поиск максимума в каждом цикле также занимает O(n)O(n).
Таких операций потребуется столько, сколько элементов в массиве, то есть nn раз.

      Сортировка бусинами (гравитационная)
Сортировка бусинами (bead sort), также известная как гравитационная
сортировка, моделирует естественное поведение бусин, падающих вниз под действием
гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл
Диннин в 2002 году.
   Принцип работы:
1. Каждый элемент массива представляется в виде горизонтального ряда бусин,
количество которых соответствует его значению.
2. Бусины располагаются на «стержнях» (как на абаке).
3. Под действием «гравитации» бусины падают вниз. for row in transposed_beads:
        row.sort(reverse=True)
4. После оседания бусин строки считываются сверху вниз — получается
отсортированный массив.
   Особенности:
Алгоритм применим только для неотрицательных целых чисел. Теоретическая сложность —
O(n), но практическая — выше из-за ограничения на диапазон и реализацию.
Временная сложность (Big-O):О(n)
   Оценка временной сложности:
Сложность обусловлена необходимостью построения вспомогательной структуры («сетки»), занимающей 
O(N×M)O(N×M) пространства, и последующей операцией пересчета элементов, которая в худших случаях достигает 
O(N⋅M)O(N⋅M). Глобально зависимость от объема данных и величины элементов приводит к общей сложности O(N⋅M)O(N⋅M).


     Поиск скачками (Jump Search)
Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при
которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы
быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
диапазона.
   Принцип работы:
1. Делится массив на блоки длины m=n.
2. Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный
искомому.
3. Если найденный элемент больше искомого, выполняется линейный поиск в
предыдущем блоке.
   Особенности:
В среднем сложность поиска O(n).
Оптимален, когда данные отсортированы и доступ к элементам осуществляется за постоянное
время.
   Временная сложность: O(n)
  Оценка временной сложности:
Время работы складывается из двух частей:
Количество прыжков: Ожидаемое количество шагов при поиске блока — это O(N)O(N).
Бинарный поиск в блоке: Сам бинарный поиск в среднем требует 
O(logNN)=O(log⁡N)=O(log⁡N)O(log NN)=O(log N)=O(logN).
Эта формула справедлива благодаря тому, что NN доминирует над logN, особенно при больших значениях NN.

      Экспоненциальный поиск (Exponential Search)
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне.
   Принцип работы:
1. Проверяется первый элемент массива.
2. Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д.,
пока не будет найден элемент, больше или равный искомому.
3. На найденном диапазоне выполняется бинарный поиск.
   Особенности:
Сложность O(log⁡n). Эффективен при поиске в очень больших отсортированных массивах с
неизвестным размером или частичным доступом.
Временная сложность: O(log⁡n)
   Оценка ВС:
Экспоненциальный поиск движется по массиву удваивающими шагами, что занимает O(logN) времени. Во-вторых, после нахождения нужной 
области применяется бинарный поиск, который также имеет сложность 
O(log⁡N)O(logN). Суммируя обе составляющие, получаем общую временную сложность O(logN).
