    #МУЛЬТИСПИСКИ
  **Python**
Мультисписки (многоуровневые, вложенные списки) реализуются предельно просто — через вложение списков друг в друга. 
Это высокоуровневый подход, не требующий явного определения структур данных. 
Основные операции:
добавление элементов — метод append() (добавляет элемент в конец списка) или insert() (вставляет элемент на заданную позицию);
удаление элементов — метод pop() (удаляет элемент по индексу и возвращает его) или remove() (удаляет первый найденный элемент 
с заданным значением).
Преимущества:
динамичность — размер списка автоматически регулируется;
гибкость — можно хранить элементы разных типов;
простота синтаксиса — создание вложенных структур занимает одну строку.

  **C++**
Мультисписки обычно реализуются через связные списки с использованием структур (struct) и указателей.
Типичный подход — двусвязный список, где каждый узел (Node) содержит:
1.данные;
2.указатель на следующий узел (next);
3.указатель на предыдущий узел (prev).
Ключевые особенности:
ручное управление памятью — необходимо явно выделять (new) и освобождать (delete) память;
высокая производительность — прямой доступ к памяти и оптимизация под конкретные задачи;
сложность реализации — требуется прописывать все операции (вставка, удаление, обход) вручную.

   **Java**
Мультисписки создаются с использованием объектно‑ориентированного подхода.
Каждый узел (Node) — это отдельный объект, содержащий:
1.данные (произвольного типа, благодаря дженерикам);
2.ссылки на предыдущий (prev) и следующий (next) узлы.
Особенности:
автоматическое управление памятью — сборщик мусора (Garbage Collector) освобождает неиспользуемые объекты;
инкапсуляция — логика работы со списком обычно скрыта в отдельном классе (например, DoublyLinkedList);
богатая стандартная библиотека — доступны готовые реализации (LinkedList), но для мультисписков часто пишут собственные классы.


      # **ОЧЕРЕДИ**
   **Python**
Для реализации можно использовать два основных подхода:
1.модуль queue.Queue — потокобезопасная реализация, подходящая для многопоточных приложений. 
Основные методы:
put(item) — добавить элемент в очередь;
get() — извлечь и вернуть элемент из очереди (при пустом состоянии может блокировать поток);
empty() — проверить, пуста ли очередь;
qsize() — получить количество элементов в очереди.
2.класс collections.deque — более быстрая реализация для однопоточных сценариев.
Основные методы:
append(item) — добавить элемент в конец очереди;
popleft() — удалить и вернуть элемент из начала очереди;
len(deque) — узнать размер очереди;
clear() — очистить очередь.


     **C++** 
Очередь реализуется через шаблон std::queue из стандартной библиотеки (<queue>). 
Это контейнер‑адаптер, который по умолчанию использует std::deque в качестве базовой структуры. 
Ключевые методы:
push(item) — добавить элемент в конец очереди;
pop() — удалить элемент из начала очереди (не возвращает значение);
empty() — проверить, пуста ли очередь;
size() — узнать количество элементов.


    **Java**
Очередь представлена интерфейсом Queue<E>, который реализуют несколько классов:
LinkedList<E> — двусвязный список, поддерживающий операции очереди;
ArrayDeque<E> — двусторонняя очередь на основе массива (более эффективна для большинства сценариев).
Основные методы интерфейса Queue:
add(item) или offer(item) — добавить элемент (второй метод возвращает false при неудаче, а не бросает исключение);
poll() — извлечь и вернуть первый элемент (возвращает null, если очередь пуста);
isEmpty() — проверить, пуста ли очередь;
size() — получить количество элементов.

      # **ДЕК (двусторонняя очередь)**
  **Python**
Используется класс collections.deque из стандартной библиотеки. Он оптимизирован для быстрых операций добавления и 
удаления элементов с обоих концов. Основные методы:
append(x) — добавить элемент x в конец очереди;
appendleft(x) — добавить элемент x в начало очереди;
pop() — удалить и вернуть элемент из конца очереди;

     **C++**
Двусторонняя очередь представлена контейнером std::deque из стандартной библиотеки шаблонов (STL). 
Его интерфейс близок к std::vector, но с поддержкой эффективных операций на обоих концах:
push_back(x) — добавить элемент x в конец;
push_front(x) — добавить элемент x в начало;
pop_back() — удалить элемент из конца;
pop_front() — удалить элемент из начала.

     **Java**
В Java двусторонняя очередь реализована через интерфейс Deque<E>, который имеет несколько популярных реализаций:
ArrayDeque<E> — основана на динамическом массиве, эффективна для большинства сценариев;
LinkedList<E> — реализована через двусвязный список, полезна при частых вставках/удалениях в середине.
Ключевые методы интерфейса Deque:
addFirst(e) — добавить элемент e в начало;
addLast(e) — добавить элемент e в конец;
removeFirst() — удалить и вернуть элемент из начала;
removeLast() — удалить и вернуть элемент из конца.


     # **ПРИОРИТЕТНАЯ ОЧЕРЕДЬ**
  **Python**
Для работы с приоритетными очередями доступны два основных инструмента:
1.queue.PriorityQueue — потокобезопасная реализация, удобная для многопоточных приложений. 
Основные методы:
put(item) — добавление элемента;
get() — извлечение элемента с наивысшим приоритетом (минимальное значение).
2.Модуль heapq — низкоуровневый инструмент для работы с кучей (heap) на основе списка. 
Требует ручного управления структурой данных, но обеспечивает большую гибкость и производительность. 
Ключевые функции:
heappush(list, item) — добавление элемента с сохранением свойств кучи;
heappop(list) — извлечение минимального элемента и восстановление структуры кучи.

     **C++**
В стандартной библиотеке C++ используется контейнер std::priority_queue, который по умолчанию организует элементы в порядке
убывания (максимальный элемент на вершине). 
Особенности:
Можно задать собственный компаратор для изменения порядка приоритетов (например, для минимальной кучи).
Основные методы:
push(item) — добавление элемента;
pop() — удаление верхнего (приоритетного) элемента;
top() — получение значения верхнего элемента без удаления.

      **Java**
В Java для реализации приоритетной очереди служит класс PriorityQueue, который:
По умолчанию сортирует элементы в естественном порядке (для Comparable‑объектов) или с использованием заданного компаратора.
Поддерживает следующие методы:
offer(item) — добавление элемента (возвращает true при успехе);
poll() — извлечение и удаление элемента с наивысшим приоритетом (возвращает null, если очередь пуста);
peek() — получение элемента с наивысшим приоритетом без удаления (возвращает null, если очередь пуста).
